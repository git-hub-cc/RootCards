import os
from pathlib import Path
from collections import defaultdict

# --- Configuration ---
# This section defines the structure and comments for the generated manifest.js.
# By changing these configurations, you can alter the output without touching the main logic.

# Defines the primary order of sections in the manifest.
TYPE_ORDER = ['pre', 'suf', 'root', 'vocab', 'other']

# Defines the sub-order of sections within each type.
LEVEL_ORDER = ['middle', 'high', 'CET-4', 'CET-6']

# Maps internal type names to human-readable comments for the manifest.
TYPE_COMMENTS = {
    'pre': 'Prefixes (前缀)',
    'suf': 'Suffixes (后缀)',
    'root': 'Roots (词根)',
    'vocab': 'Vocabulary (词汇)',
    'other': 'Specialized Topics (专题)', # For files like etymology_basics.json
}

# Maps internal level names to human-readable comments.
LEVEL_COMMENTS = {
    'middle': '初中阶段 (Middle School)',
    'high': '高中阶段 (High School)',
    'CET-4': 'CET-4 (大学英语四级)',
    'CET-6': 'CET-6 (大学英语六级)',
}

# The header and footer for the manifest.js file.
MANIFEST_HEADER = """// =================================================================================
// 数据清单 (Data Manifest) - Automatically generated by Python script
// ---------------------------------------------------------------------------------
// This file lists all the data files for the application.
// It is generated by scanning the 'data' directory. Do not edit manually.
// =================================================================================

const DATA_FILES = [
"""
MANIFEST_FOOTER = "];\n"

def generate_manifest():
    """
    Scans the 'data' directory for .json files, categorizes them based on their
    path, and generates a manifest.js file with the structured file list.
    """
    base_dir = Path('../data')
    if not base_dir.is_dir():
        print(f"Error: The '{base_dir}' directory was not found in the current location.")
        print("Please run this script from your project's root directory.")
        return

    print(f"Scanning for JSON files in '{base_dir}'...")
    all_json_files = list(base_dir.rglob('*.json'))

    # Categorize files based on their path structure.
    # The structure is: categorized[type][level] = [list_of_file_paths]
    categorized_files = defaultdict(lambda: defaultdict(list))

    for path in all_json_files:
        # Use as_posix() to ensure forward slashes, which is standard for web paths.
        posix_path = path.as_posix()
        parts = path.parts

        # Expected path structures:
        # 'data' / level / type / file.json  (e.g., data/middle/pre/re.json)
        # 'data' / level / file.json        (e.g., data/middle/vocab_a.json)
        if len(parts) < 3 or parts[0] != 'data':
            print(f"  - Skipping unrecognized path: {posix_path}")
            continue

        level = parts[1]

        if len(parts) >= 4:
            # Structure: data/level/type/file.json
            type_ = parts[2]
            categorized_files[type_][level].append(posix_path)
        elif len(parts) == 3:
            # Structure: data/level/file.json
            filename = parts[2]
            if filename.startswith('vocab_'):
                type_ = 'vocab'
            else:
                type_ = 'other' # For files like 'etymology_basics.json'
            categorized_files[type_][level].append(posix_path)

    # Build the content for the manifest.js file line by line.
    output_lines = [MANIFEST_HEADER]
    is_first_section = True

    for type_key in TYPE_ORDER:
        if type_key in categorized_files:

            # Add a blank line before new major sections, but not at the very top.
            if not is_first_section:
                output_lines.append('\n')
            is_first_section = False

            comment = TYPE_COMMENTS.get(type_key, type_key.title())
            output_lines.append(f"    // --- {comment} ---\n")

            for level_key in LEVEL_ORDER:
                if level_key in categorized_files[type_key]:
                    files = sorted(categorized_files[type_key][level_key])
                    if not files:
                        continue

                    level_comment = LEVEL_COMMENTS.get(level_key, level_key.title())
                    output_lines.append(f"    // {level_comment}\n")

                    for file_path in files:
                        output_lines.append(f"    '{file_path}',\n")

    # Clean up trailing comma from the last file entry
    if len(output_lines) > 1:
        # Loop backwards to find the last line that is a file path
        for i in range(len(output_lines) - 1, 0, -1):
            line = output_lines[i]
            if line.strip().startswith("'") and line.strip().endswith("',"):
                output_lines[i] = line.rstrip(",\n") + "\n"
                break

    output_lines.append(MANIFEST_FOOTER)

    # Write the content to the manifest.js file.
    output_filename = '../manifest.js'
    try:
        with open(output_filename, 'w', encoding='utf-8', newline='\n') as f:
            f.write("".join(output_lines))
        print(f"\nSuccessfully generated '{output_filename}' with {len(all_json_files)} files.")
    except IOError as e:
        print(f"Error writing to file '{output_filename}': {e}")


if __name__ == "__main__":
    generate_manifest()